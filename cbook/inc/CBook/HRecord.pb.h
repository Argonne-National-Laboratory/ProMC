// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HRecord.proto

#ifndef PROTOBUF_HRecord_2eproto__INCLUDED
#define PROTOBUF_HRecord_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace promc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_HRecord_2eproto();
void protobuf_AssignDesc_HRecord_2eproto();
void protobuf_ShutdownFile_HRecord_2eproto();

class Record;
class Record_P0I;
class Record_P0D;
class Record_PXY;
class Record_PXYZ;
class Record_P1D;
class Record_H1D;
class Record_H2D;
class Record_F1D;
class Record_F2D;
class Record_FND;
class Record_FPR;
class Record_PND;
class Record_PNI;

// ===================================================================

class Record_P0I : public ::google::protobuf::Message {
 public:
  Record_P0I();
  virtual ~Record_P0I();

  Record_P0I(const Record_P0I& from);

  inline Record_P0I& operator=(const Record_P0I& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_P0I& default_instance();

  void Swap(Record_P0I* other);

  // implements Message ----------------------------------------------

  Record_P0I* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_P0I& from);
  void MergeFrom(const Record_P0I& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int64 value = 2 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int64 value(int index) const;
  inline void set_value(int index, ::google::protobuf::int64 value);
  inline void add_value(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:promc.Record.P0I)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_P0I* default_instance_;
};
// -------------------------------------------------------------------

class Record_P0D : public ::google::protobuf::Message {
 public:
  Record_P0D();
  virtual ~Record_P0D();

  Record_P0D(const Record_P0D& from);

  inline Record_P0D& operator=(const Record_P0D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_P0D& default_instance();

  void Swap(Record_P0D* other);

  // implements Message ----------------------------------------------

  Record_P0D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_P0D& from);
  void MergeFrom(const Record_P0D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double value = 2 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:promc.Record.P0D)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< double > value_;
  mutable int _value_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_P0D* default_instance_;
};
// -------------------------------------------------------------------

class Record_PXY : public ::google::protobuf::Message {
 public:
  Record_PXY();
  virtual ~Record_PXY();

  Record_PXY(const Record_PXY& from);

  inline Record_PXY& operator=(const Record_PXY& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_PXY& default_instance();

  void Swap(Record_PXY* other);

  // implements Message ----------------------------------------------

  Record_PXY* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_PXY& from);
  void MergeFrom(const Record_PXY& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double x = 2 [packed = true];
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline double x(int index) const;
  inline void set_x(int index, double value);
  inline void add_x(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      x() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_x();

  // repeated double y = 3 [packed = true];
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline double y(int index) const;
  inline void set_y(int index, double value);
  inline void add_y(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      y() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_y();

  // @@protoc_insertion_point(class_scope:promc.Record.PXY)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< double > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > y_;
  mutable int _y_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_PXY* default_instance_;
};
// -------------------------------------------------------------------

class Record_PXYZ : public ::google::protobuf::Message {
 public:
  Record_PXYZ();
  virtual ~Record_PXYZ();

  Record_PXYZ(const Record_PXYZ& from);

  inline Record_PXYZ& operator=(const Record_PXYZ& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_PXYZ& default_instance();

  void Swap(Record_PXYZ* other);

  // implements Message ----------------------------------------------

  Record_PXYZ* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_PXYZ& from);
  void MergeFrom(const Record_PXYZ& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double x = 2 [packed = true];
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline double x(int index) const;
  inline void set_x(int index, double value);
  inline void add_x(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      x() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_x();

  // repeated double y = 3 [packed = true];
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline double y(int index) const;
  inline void set_y(int index, double value);
  inline void add_y(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      y() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_y();

  // repeated double z = 4 [packed = true];
  inline int z_size() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline double z(int index) const;
  inline void set_z(int index, double value);
  inline void add_z(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      z() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_z();

  // @@protoc_insertion_point(class_scope:promc.Record.PXYZ)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< double > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > y_;
  mutable int _y_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > z_;
  mutable int _z_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_PXYZ* default_instance_;
};
// -------------------------------------------------------------------

class Record_P1D : public ::google::protobuf::Message {
 public:
  Record_P1D();
  virtual ~Record_P1D();

  Record_P1D(const Record_P1D& from);

  inline Record_P1D& operator=(const Record_P1D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_P1D& default_instance();

  void Swap(Record_P1D* other);

  // implements Message ----------------------------------------------

  Record_P1D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_P1D& from);
  void MergeFrom(const Record_P1D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double x = 2 [packed = true];
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline double x(int index) const;
  inline void set_x(int index, double value);
  inline void add_x(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      x() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_x();

  // repeated double y = 3 [packed = true];
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline double y(int index) const;
  inline void set_y(int index, double value);
  inline void add_y(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      y() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_y();

  // repeated double xleft = 4 [packed = true];
  inline int xleft_size() const;
  inline void clear_xleft();
  static const int kXleftFieldNumber = 4;
  inline double xleft(int index) const;
  inline void set_xleft(int index, double value);
  inline void add_xleft(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      xleft() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_xleft();

  // repeated double xright = 5 [packed = true];
  inline int xright_size() const;
  inline void clear_xright();
  static const int kXrightFieldNumber = 5;
  inline double xright(int index) const;
  inline void set_xright(int index, double value);
  inline void add_xright(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      xright() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_xright();

  // repeated double yupper = 6 [packed = true];
  inline int yupper_size() const;
  inline void clear_yupper();
  static const int kYupperFieldNumber = 6;
  inline double yupper(int index) const;
  inline void set_yupper(int index, double value);
  inline void add_yupper(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      yupper() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_yupper();

  // repeated double ylower = 7 [packed = true];
  inline int ylower_size() const;
  inline void clear_ylower();
  static const int kYlowerFieldNumber = 7;
  inline double ylower(int index) const;
  inline void set_ylower(int index, double value);
  inline void add_ylower(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      ylower() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_ylower();

  // repeated double xsysleft = 8 [packed = true];
  inline int xsysleft_size() const;
  inline void clear_xsysleft();
  static const int kXsysleftFieldNumber = 8;
  inline double xsysleft(int index) const;
  inline void set_xsysleft(int index, double value);
  inline void add_xsysleft(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      xsysleft() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_xsysleft();

  // repeated double xsysright = 9 [packed = true];
  inline int xsysright_size() const;
  inline void clear_xsysright();
  static const int kXsysrightFieldNumber = 9;
  inline double xsysright(int index) const;
  inline void set_xsysright(int index, double value);
  inline void add_xsysright(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      xsysright() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_xsysright();

  // repeated double ysysupper = 10 [packed = true];
  inline int ysysupper_size() const;
  inline void clear_ysysupper();
  static const int kYsysupperFieldNumber = 10;
  inline double ysysupper(int index) const;
  inline void set_ysysupper(int index, double value);
  inline void add_ysysupper(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      ysysupper() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_ysysupper();

  // repeated double ysyslower = 11 [packed = true];
  inline int ysyslower_size() const;
  inline void clear_ysyslower();
  static const int kYsyslowerFieldNumber = 11;
  inline double ysyslower(int index) const;
  inline void set_ysyslower(int index, double value);
  inline void add_ysyslower(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      ysyslower() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_ysyslower();

  // @@protoc_insertion_point(class_scope:promc.Record.P1D)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< double > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > y_;
  mutable int _y_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > xleft_;
  mutable int _xleft_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > xright_;
  mutable int _xright_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > yupper_;
  mutable int _yupper_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > ylower_;
  mutable int _ylower_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > xsysleft_;
  mutable int _xsysleft_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > xsysright_;
  mutable int _xsysright_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > ysysupper_;
  mutable int _ysysupper_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > ysyslower_;
  mutable int _ysyslower_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_P1D* default_instance_;
};
// -------------------------------------------------------------------

class Record_H1D : public ::google::protobuf::Message {
 public:
  Record_H1D();
  virtual ~Record_H1D();

  Record_H1D(const Record_H1D& from);

  inline Record_H1D& operator=(const Record_H1D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_H1D& default_instance();

  void Swap(Record_H1D* other);

  // implements Message ----------------------------------------------

  Record_H1D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_H1D& from);
  void MergeFrom(const Record_H1D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double heights = 2 [packed = true];
  inline int heights_size() const;
  inline void clear_heights();
  static const int kHeightsFieldNumber = 2;
  inline double heights(int index) const;
  inline void set_heights(int index, double value);
  inline void add_heights(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      heights() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_heights();

  // repeated double errors = 3 [packed = true];
  inline int errors_size() const;
  inline void clear_errors();
  static const int kErrorsFieldNumber = 3;
  inline double errors(int index) const;
  inline void set_errors(int index, double value);
  inline void add_errors(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      errors() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_errors();

  // repeated double means = 4 [packed = true];
  inline int means_size() const;
  inline void clear_means();
  static const int kMeansFieldNumber = 4;
  inline double means(int index) const;
  inline void set_means(int index, double value);
  inline void add_means(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      means() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_means();

  // repeated double rmses = 5 [packed = true];
  inline int rmses_size() const;
  inline void clear_rmses();
  static const int kRmsesFieldNumber = 5;
  inline double rmses(int index) const;
  inline void set_rmses(int index, double value);
  inline void add_rmses(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      rmses() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_rmses();

  // repeated int32 entries = 6 [packed = true];
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 6;
  inline ::google::protobuf::int32 entries(int index) const;
  inline void set_entries(int index, ::google::protobuf::int32 value);
  inline void add_entries(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      entries() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_entries();

  // repeated double edges = 7 [packed = true];
  inline int edges_size() const;
  inline void clear_edges();
  static const int kEdgesFieldNumber = 7;
  inline double edges(int index) const;
  inline void set_edges(int index, double value);
  inline void add_edges(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      edges() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_edges();

  // required int32 bins = 8;
  inline bool has_bins() const;
  inline void clear_bins();
  static const int kBinsFieldNumber = 8;
  inline ::google::protobuf::int32 bins() const;
  inline void set_bins(::google::protobuf::int32 value);

  // required double min = 9;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 9;
  inline double min() const;
  inline void set_min(double value);

  // required double max = 10;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 10;
  inline double max() const;
  inline void set_max(double value);

  // optional int32 allentries = 11;
  inline bool has_allentries() const;
  inline void clear_allentries();
  static const int kAllentriesFieldNumber = 11;
  inline ::google::protobuf::int32 allentries() const;
  inline void set_allentries(::google::protobuf::int32 value);

  // optional int32 nentries = 12;
  inline bool has_nentries() const;
  inline void clear_nentries();
  static const int kNentriesFieldNumber = 12;
  inline ::google::protobuf::int32 nentries() const;
  inline void set_nentries(::google::protobuf::int32 value);

  // optional double underflow = 13;
  inline bool has_underflow() const;
  inline void clear_underflow();
  static const int kUnderflowFieldNumber = 13;
  inline double underflow() const;
  inline void set_underflow(double value);

  // optional double overflow = 14;
  inline bool has_overflow() const;
  inline void clear_overflow();
  static const int kOverflowFieldNumber = 14;
  inline double overflow() const;
  inline void set_overflow(double value);

  // optional double rms = 15;
  inline bool has_rms() const;
  inline void clear_rms();
  static const int kRmsFieldNumber = 15;
  inline double rms() const;
  inline void set_rms(double value);

  // optional double mean = 16;
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 16;
  inline double mean() const;
  inline void set_mean(double value);

  // required bool isFixedBins = 17;
  inline bool has_isfixedbins() const;
  inline void clear_isfixedbins();
  static const int kIsFixedBinsFieldNumber = 17;
  inline bool isfixedbins() const;
  inline void set_isfixedbins(bool value);

  // @@protoc_insertion_point(class_scope:promc.Record.H1D)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bins();
  inline void clear_has_bins();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_allentries();
  inline void clear_has_allentries();
  inline void set_has_nentries();
  inline void clear_has_nentries();
  inline void set_has_underflow();
  inline void clear_has_underflow();
  inline void set_has_overflow();
  inline void clear_has_overflow();
  inline void set_has_rms();
  inline void clear_has_rms();
  inline void set_has_mean();
  inline void clear_has_mean();
  inline void set_has_isfixedbins();
  inline void clear_has_isfixedbins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< double > heights_;
  mutable int _heights_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > errors_;
  mutable int _errors_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > means_;
  mutable int _means_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > rmses_;
  mutable int _rmses_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > entries_;
  mutable int _entries_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > edges_;
  mutable int _edges_cached_byte_size_;
  double min_;
  ::google::protobuf::int32 bins_;
  ::google::protobuf::int32 allentries_;
  double max_;
  double underflow_;
  double overflow_;
  ::google::protobuf::int32 nentries_;
  bool isfixedbins_;
  double rms_;
  double mean_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_H1D* default_instance_;
};
// -------------------------------------------------------------------

class Record_H2D : public ::google::protobuf::Message {
 public:
  Record_H2D();
  virtual ~Record_H2D();

  Record_H2D(const Record_H2D& from);

  inline Record_H2D& operator=(const Record_H2D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_H2D& default_instance();

  void Swap(Record_H2D* other);

  // implements Message ----------------------------------------------

  Record_H2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_H2D& from);
  void MergeFrom(const Record_H2D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double heights = 2 [packed = true];
  inline int heights_size() const;
  inline void clear_heights();
  static const int kHeightsFieldNumber = 2;
  inline double heights(int index) const;
  inline void set_heights(int index, double value);
  inline void add_heights(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      heights() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_heights();

  // repeated double errors = 3 [packed = true];
  inline int errors_size() const;
  inline void clear_errors();
  static const int kErrorsFieldNumber = 3;
  inline double errors(int index) const;
  inline void set_errors(int index, double value);
  inline void add_errors(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      errors() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_errors();

  // repeated double meansX = 4 [packed = true];
  inline int meansx_size() const;
  inline void clear_meansx();
  static const int kMeansXFieldNumber = 4;
  inline double meansx(int index) const;
  inline void set_meansx(int index, double value);
  inline void add_meansx(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      meansx() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_meansx();

  // repeated double rmsesX = 5 [packed = true];
  inline int rmsesx_size() const;
  inline void clear_rmsesx();
  static const int kRmsesXFieldNumber = 5;
  inline double rmsesx(int index) const;
  inline void set_rmsesx(int index, double value);
  inline void add_rmsesx(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      rmsesx() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_rmsesx();

  // repeated int32 entries = 6 [packed = true];
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 6;
  inline ::google::protobuf::int32 entries(int index) const;
  inline void set_entries(int index, ::google::protobuf::int32 value);
  inline void add_entries(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      entries() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_entries();

  // repeated double meansY = 7 [packed = true];
  inline int meansy_size() const;
  inline void clear_meansy();
  static const int kMeansYFieldNumber = 7;
  inline double meansy(int index) const;
  inline void set_meansy(int index, double value);
  inline void add_meansy(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      meansy() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_meansy();

  // repeated double rmsesY = 8 [packed = true];
  inline int rmsesy_size() const;
  inline void clear_rmsesy();
  static const int kRmsesYFieldNumber = 8;
  inline double rmsesy(int index) const;
  inline void set_rmsesy(int index, double value);
  inline void add_rmsesy(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      rmsesy() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_rmsesy();

  // repeated double summary = 9 [packed = true];
  inline int summary_size() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 9;
  inline double summary(int index) const;
  inline void set_summary(int index, double value);
  inline void add_summary(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      summary() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_summary();

  // repeated double outofrange = 10 [packed = true];
  inline int outofrange_size() const;
  inline void clear_outofrange();
  static const int kOutofrangeFieldNumber = 10;
  inline double outofrange(int index) const;
  inline void set_outofrange(int index, double value);
  inline void add_outofrange(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      outofrange() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_outofrange();

  // optional int32 allentries = 11;
  inline bool has_allentries() const;
  inline void clear_allentries();
  static const int kAllentriesFieldNumber = 11;
  inline ::google::protobuf::int32 allentries() const;
  inline void set_allentries(::google::protobuf::int32 value);

  // optional int32 nentries = 12;
  inline bool has_nentries() const;
  inline void clear_nentries();
  static const int kNentriesFieldNumber = 12;
  inline ::google::protobuf::int32 nentries() const;
  inline void set_nentries(::google::protobuf::int32 value);

  // required bool isFixedBins = 13;
  inline bool has_isfixedbins() const;
  inline void clear_isfixedbins();
  static const int kIsFixedBinsFieldNumber = 13;
  inline bool isfixedbins() const;
  inline void set_isfixedbins(bool value);

  // @@protoc_insertion_point(class_scope:promc.Record.H2D)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_allentries();
  inline void clear_has_allentries();
  inline void set_has_nentries();
  inline void clear_has_nentries();
  inline void set_has_isfixedbins();
  inline void clear_has_isfixedbins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< double > heights_;
  mutable int _heights_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > errors_;
  mutable int _errors_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > meansx_;
  mutable int _meansx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > rmsesx_;
  mutable int _rmsesx_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > entries_;
  mutable int _entries_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > meansy_;
  mutable int _meansy_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > rmsesy_;
  mutable int _rmsesy_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > summary_;
  mutable int _summary_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > outofrange_;
  mutable int _outofrange_cached_byte_size_;
  ::google::protobuf::int32 allentries_;
  ::google::protobuf::int32 nentries_;
  bool isfixedbins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_H2D* default_instance_;
};
// -------------------------------------------------------------------

class Record_F1D : public ::google::protobuf::Message {
 public:
  Record_F1D();
  virtual ~Record_F1D();

  Record_F1D(const Record_F1D& from);

  inline Record_F1D& operator=(const Record_F1D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_F1D& default_instance();

  void Swap(Record_F1D* other);

  // implements Message ----------------------------------------------

  Record_F1D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_F1D& from);
  void MergeFrom(const Record_F1D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string definition = 2;
  inline bool has_definition() const;
  inline void clear_definition();
  static const int kDefinitionFieldNumber = 2;
  inline const ::std::string& definition() const;
  inline void set_definition(const ::std::string& value);
  inline void set_definition(const char* value);
  inline void set_definition(const char* value, size_t size);
  inline ::std::string* mutable_definition();
  inline ::std::string* release_definition();
  inline void set_allocated_definition(::std::string* definition);

  // optional double min = 3;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 3;
  inline double min() const;
  inline void set_min(double value);

  // optional double max = 4;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 4;
  inline double max() const;
  inline void set_max(double value);

  // @@protoc_insertion_point(class_scope:promc.Record.F1D)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_definition();
  inline void clear_has_definition();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* definition_;
  double min_;
  double max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_F1D* default_instance_;
};
// -------------------------------------------------------------------

class Record_F2D : public ::google::protobuf::Message {
 public:
  Record_F2D();
  virtual ~Record_F2D();

  Record_F2D(const Record_F2D& from);

  inline Record_F2D& operator=(const Record_F2D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_F2D& default_instance();

  void Swap(Record_F2D* other);

  // implements Message ----------------------------------------------

  Record_F2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_F2D& from);
  void MergeFrom(const Record_F2D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string definition = 2;
  inline bool has_definition() const;
  inline void clear_definition();
  static const int kDefinitionFieldNumber = 2;
  inline const ::std::string& definition() const;
  inline void set_definition(const ::std::string& value);
  inline void set_definition(const char* value);
  inline void set_definition(const char* value, size_t size);
  inline ::std::string* mutable_definition();
  inline ::std::string* release_definition();
  inline void set_allocated_definition(::std::string* definition);

  // optional double minX = 3;
  inline bool has_minx() const;
  inline void clear_minx();
  static const int kMinXFieldNumber = 3;
  inline double minx() const;
  inline void set_minx(double value);

  // optional double maxX = 4;
  inline bool has_maxx() const;
  inline void clear_maxx();
  static const int kMaxXFieldNumber = 4;
  inline double maxx() const;
  inline void set_maxx(double value);

  // optional double minY = 5;
  inline bool has_miny() const;
  inline void clear_miny();
  static const int kMinYFieldNumber = 5;
  inline double miny() const;
  inline void set_miny(double value);

  // optional double maxY = 6;
  inline bool has_maxy() const;
  inline void clear_maxy();
  static const int kMaxYFieldNumber = 6;
  inline double maxy() const;
  inline void set_maxy(double value);

  // @@protoc_insertion_point(class_scope:promc.Record.F2D)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_definition();
  inline void clear_has_definition();
  inline void set_has_minx();
  inline void clear_has_minx();
  inline void set_has_maxx();
  inline void clear_has_maxx();
  inline void set_has_miny();
  inline void clear_has_miny();
  inline void set_has_maxy();
  inline void clear_has_maxy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* definition_;
  double minx_;
  double maxx_;
  double miny_;
  double maxy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_F2D* default_instance_;
};
// -------------------------------------------------------------------

class Record_FND : public ::google::protobuf::Message {
 public:
  Record_FND();
  virtual ~Record_FND();

  Record_FND(const Record_FND& from);

  inline Record_FND& operator=(const Record_FND& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_FND& default_instance();

  void Swap(Record_FND* other);

  // implements Message ----------------------------------------------

  Record_FND* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_FND& from);
  void MergeFrom(const Record_FND& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string definition = 2;
  inline bool has_definition() const;
  inline void clear_definition();
  static const int kDefinitionFieldNumber = 2;
  inline const ::std::string& definition() const;
  inline void set_definition(const ::std::string& value);
  inline void set_definition(const char* value);
  inline void set_definition(const char* value, size_t size);
  inline ::std::string* mutable_definition();
  inline ::std::string* release_definition();
  inline void set_allocated_definition(::std::string* definition);

  // required string vars = 3;
  inline bool has_vars() const;
  inline void clear_vars();
  static const int kVarsFieldNumber = 3;
  inline const ::std::string& vars() const;
  inline void set_vars(const ::std::string& value);
  inline void set_vars(const char* value);
  inline void set_vars(const char* value, size_t size);
  inline ::std::string* mutable_vars();
  inline ::std::string* release_vars();
  inline void set_allocated_vars(::std::string* vars);

  // @@protoc_insertion_point(class_scope:promc.Record.FND)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_definition();
  inline void clear_has_definition();
  inline void set_has_vars();
  inline void clear_has_vars();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* definition_;
  ::std::string* vars_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_FND* default_instance_;
};
// -------------------------------------------------------------------

class Record_FPR : public ::google::protobuf::Message {
 public:
  Record_FPR();
  virtual ~Record_FPR();

  Record_FPR(const Record_FPR& from);

  inline Record_FPR& operator=(const Record_FPR& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_FPR& default_instance();

  void Swap(Record_FPR* other);

  // implements Message ----------------------------------------------

  Record_FPR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_FPR& from);
  void MergeFrom(const Record_FPR& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string definition = 2;
  inline bool has_definition() const;
  inline void clear_definition();
  static const int kDefinitionFieldNumber = 2;
  inline const ::std::string& definition() const;
  inline void set_definition(const ::std::string& value);
  inline void set_definition(const char* value);
  inline void set_definition(const char* value, size_t size);
  inline ::std::string* mutable_definition();
  inline ::std::string* release_definition();
  inline void set_allocated_definition(::std::string* definition);

  // required int32 divU = 3;
  inline bool has_divu() const;
  inline void clear_divu();
  static const int kDivUFieldNumber = 3;
  inline ::google::protobuf::int32 divu() const;
  inline void set_divu(::google::protobuf::int32 value);

  // required int32 divV = 4;
  inline bool has_divv() const;
  inline void clear_divv();
  static const int kDivVFieldNumber = 4;
  inline ::google::protobuf::int32 divv() const;
  inline void set_divv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:promc.Record.FPR)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_definition();
  inline void clear_has_definition();
  inline void set_has_divu();
  inline void clear_has_divu();
  inline void set_has_divv();
  inline void clear_has_divv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* definition_;
  ::google::protobuf::int32 divu_;
  ::google::protobuf::int32 divv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_FPR* default_instance_;
};
// -------------------------------------------------------------------

class Record_PND : public ::google::protobuf::Message {
 public:
  Record_PND();
  virtual ~Record_PND();

  Record_PND(const Record_PND& from);

  inline Record_PND& operator=(const Record_PND& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_PND& default_instance();

  void Swap(Record_PND* other);

  // implements Message ----------------------------------------------

  Record_PND* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_PND& from);
  void MergeFrom(const Record_PND& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double value = 2 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value(int index) const;
  inline void set_value(int index, double value);
  inline void add_value(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      value() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // required int32 dimension = 3;
  inline bool has_dimension() const;
  inline void clear_dimension();
  static const int kDimensionFieldNumber = 3;
  inline ::google::protobuf::int32 dimension() const;
  inline void set_dimension(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:promc.Record.PND)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_dimension();
  inline void clear_has_dimension();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< double > value_;
  mutable int _value_cached_byte_size_;
  ::google::protobuf::int32 dimension_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_PND* default_instance_;
};
// -------------------------------------------------------------------

class Record_PNI : public ::google::protobuf::Message {
 public:
  Record_PNI();
  virtual ~Record_PNI();

  Record_PNI(const Record_PNI& from);

  inline Record_PNI& operator=(const Record_PNI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record_PNI& default_instance();

  void Swap(Record_PNI* other);

  // implements Message ----------------------------------------------

  Record_PNI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record_PNI& from);
  void MergeFrom(const Record_PNI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "none"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 value = 2 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::int32 value);
  inline void add_value(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_value();

  // required int32 dimension = 3;
  inline bool has_dimension() const;
  inline void clear_dimension();
  static const int kDimensionFieldNumber = 3;
  inline ::google::protobuf::int32 dimension() const;
  inline void set_dimension(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:promc.Record.PNI)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_dimension();
  inline void clear_has_dimension();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > value_;
  mutable int _value_cached_byte_size_;
  ::google::protobuf::int32 dimension_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record_PNI* default_instance_;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  void Swap(Record* other);

  // implements Message ----------------------------------------------

  Record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Record_P0I P0I;
  typedef Record_P0D P0D;
  typedef Record_PXY PXY;
  typedef Record_PXYZ PXYZ;
  typedef Record_P1D P1D;
  typedef Record_H1D H1D;
  typedef Record_H2D H2D;
  typedef Record_F1D F1D;
  typedef Record_F2D F2D;
  typedef Record_FND FND;
  typedef Record_FPR FPR;
  typedef Record_PND PND;
  typedef Record_PNI PNI;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .promc.Record.P0I p0I = 2;
  inline bool has_p0i() const;
  inline void clear_p0i();
  static const int kP0IFieldNumber = 2;
  inline const ::promc::Record_P0I& p0i() const;
  inline ::promc::Record_P0I* mutable_p0i();
  inline ::promc::Record_P0I* release_p0i();
  inline void set_allocated_p0i(::promc::Record_P0I* p0i);

  // optional .promc.Record.P0D p0D = 3;
  inline bool has_p0d() const;
  inline void clear_p0d();
  static const int kP0DFieldNumber = 3;
  inline const ::promc::Record_P0D& p0d() const;
  inline ::promc::Record_P0D* mutable_p0d();
  inline ::promc::Record_P0D* release_p0d();
  inline void set_allocated_p0d(::promc::Record_P0D* p0d);

  // optional .promc.Record.PXY pXY = 4;
  inline bool has_pxy() const;
  inline void clear_pxy();
  static const int kPXYFieldNumber = 4;
  inline const ::promc::Record_PXY& pxy() const;
  inline ::promc::Record_PXY* mutable_pxy();
  inline ::promc::Record_PXY* release_pxy();
  inline void set_allocated_pxy(::promc::Record_PXY* pxy);

  // optional .promc.Record.PXYZ pXYZ = 5;
  inline bool has_pxyz() const;
  inline void clear_pxyz();
  static const int kPXYZFieldNumber = 5;
  inline const ::promc::Record_PXYZ& pxyz() const;
  inline ::promc::Record_PXYZ* mutable_pxyz();
  inline ::promc::Record_PXYZ* release_pxyz();
  inline void set_allocated_pxyz(::promc::Record_PXYZ* pxyz);

  // optional .promc.Record.P1D p1D = 6;
  inline bool has_p1d() const;
  inline void clear_p1d();
  static const int kP1DFieldNumber = 6;
  inline const ::promc::Record_P1D& p1d() const;
  inline ::promc::Record_P1D* mutable_p1d();
  inline ::promc::Record_P1D* release_p1d();
  inline void set_allocated_p1d(::promc::Record_P1D* p1d);

  // optional .promc.Record.H1D h1D = 7;
  inline bool has_h1d() const;
  inline void clear_h1d();
  static const int kH1DFieldNumber = 7;
  inline const ::promc::Record_H1D& h1d() const;
  inline ::promc::Record_H1D* mutable_h1d();
  inline ::promc::Record_H1D* release_h1d();
  inline void set_allocated_h1d(::promc::Record_H1D* h1d);

  // optional .promc.Record.H2D h2D = 8;
  inline bool has_h2d() const;
  inline void clear_h2d();
  static const int kH2DFieldNumber = 8;
  inline const ::promc::Record_H2D& h2d() const;
  inline ::promc::Record_H2D* mutable_h2d();
  inline ::promc::Record_H2D* release_h2d();
  inline void set_allocated_h2d(::promc::Record_H2D* h2d);

  // optional .promc.Record.F1D f1D = 9;
  inline bool has_f1d() const;
  inline void clear_f1d();
  static const int kF1DFieldNumber = 9;
  inline const ::promc::Record_F1D& f1d() const;
  inline ::promc::Record_F1D* mutable_f1d();
  inline ::promc::Record_F1D* release_f1d();
  inline void set_allocated_f1d(::promc::Record_F1D* f1d);

  // optional .promc.Record.F2D f2D = 10;
  inline bool has_f2d() const;
  inline void clear_f2d();
  static const int kF2DFieldNumber = 10;
  inline const ::promc::Record_F2D& f2d() const;
  inline ::promc::Record_F2D* mutable_f2d();
  inline ::promc::Record_F2D* release_f2d();
  inline void set_allocated_f2d(::promc::Record_F2D* f2d);

  // optional .promc.Record.FND fND = 11;
  inline bool has_fnd() const;
  inline void clear_fnd();
  static const int kFNDFieldNumber = 11;
  inline const ::promc::Record_FND& fnd() const;
  inline ::promc::Record_FND* mutable_fnd();
  inline ::promc::Record_FND* release_fnd();
  inline void set_allocated_fnd(::promc::Record_FND* fnd);

  // optional .promc.Record.FPR fPR = 12;
  inline bool has_fpr() const;
  inline void clear_fpr();
  static const int kFPRFieldNumber = 12;
  inline const ::promc::Record_FPR& fpr() const;
  inline ::promc::Record_FPR* mutable_fpr();
  inline ::promc::Record_FPR* release_fpr();
  inline void set_allocated_fpr(::promc::Record_FPR* fpr);

  // optional .promc.Record.PND pND = 13;
  inline bool has_pnd() const;
  inline void clear_pnd();
  static const int kPNDFieldNumber = 13;
  inline const ::promc::Record_PND& pnd() const;
  inline ::promc::Record_PND* mutable_pnd();
  inline ::promc::Record_PND* release_pnd();
  inline void set_allocated_pnd(::promc::Record_PND* pnd);

  // optional .promc.Record.PNI pNI = 14;
  inline bool has_pni() const;
  inline void clear_pni();
  static const int kPNIFieldNumber = 14;
  inline const ::promc::Record_PNI& pni() const;
  inline ::promc::Record_PNI* mutable_pni();
  inline ::promc::Record_PNI* release_pni();
  inline void set_allocated_pni(::promc::Record_PNI* pni);

  // @@protoc_insertion_point(class_scope:promc.Record)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_p0i();
  inline void clear_has_p0i();
  inline void set_has_p0d();
  inline void clear_has_p0d();
  inline void set_has_pxy();
  inline void clear_has_pxy();
  inline void set_has_pxyz();
  inline void clear_has_pxyz();
  inline void set_has_p1d();
  inline void clear_has_p1d();
  inline void set_has_h1d();
  inline void clear_has_h1d();
  inline void set_has_h2d();
  inline void clear_has_h2d();
  inline void set_has_f1d();
  inline void clear_has_f1d();
  inline void set_has_f2d();
  inline void clear_has_f2d();
  inline void set_has_fnd();
  inline void clear_has_fnd();
  inline void set_has_fpr();
  inline void clear_has_fpr();
  inline void set_has_pnd();
  inline void clear_has_pnd();
  inline void set_has_pni();
  inline void clear_has_pni();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::promc::Record_P0I* p0i_;
  ::promc::Record_P0D* p0d_;
  ::promc::Record_PXY* pxy_;
  ::promc::Record_PXYZ* pxyz_;
  ::promc::Record_P1D* p1d_;
  ::promc::Record_H1D* h1d_;
  ::promc::Record_H2D* h2d_;
  ::promc::Record_F1D* f1d_;
  ::promc::Record_F2D* f2d_;
  ::promc::Record_FND* fnd_;
  ::promc::Record_FPR* fpr_;
  ::promc::Record_PND* pnd_;
  ::promc::Record_PNI* pni_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_HRecord_2eproto();
  friend void protobuf_AssignDesc_HRecord_2eproto();
  friend void protobuf_ShutdownFile_HRecord_2eproto();

  void InitAsDefaultInstance();
  static Record* default_instance_;
};
// ===================================================================


// ===================================================================

// Record_P0I

// required string name = 1 [default = "none"];
inline bool Record_P0I::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_P0I::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_P0I::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_P0I::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_P0I::name() const {
  return *name_;
}
inline void Record_P0I::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_P0I::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_P0I::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_P0I::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_P0I::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_P0I::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated int64 value = 2 [packed = true];
inline int Record_P0I::value_size() const {
  return value_.size();
}
inline void Record_P0I::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int64 Record_P0I::value(int index) const {
  return value_.Get(index);
}
inline void Record_P0I::set_value(int index, ::google::protobuf::int64 value) {
  value_.Set(index, value);
}
inline void Record_P0I::add_value(::google::protobuf::int64 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Record_P0I::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Record_P0I::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// Record_P0D

// required string name = 1 [default = "none"];
inline bool Record_P0D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_P0D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_P0D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_P0D::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_P0D::name() const {
  return *name_;
}
inline void Record_P0D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_P0D::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_P0D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_P0D::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_P0D::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_P0D::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated double value = 2 [packed = true];
inline int Record_P0D::value_size() const {
  return value_.size();
}
inline void Record_P0D::clear_value() {
  value_.Clear();
}
inline double Record_P0D::value(int index) const {
  return value_.Get(index);
}
inline void Record_P0D::set_value(int index, double value) {
  value_.Set(index, value);
}
inline void Record_P0D::add_value(double value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P0D::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P0D::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// Record_PXY

// required string name = 1 [default = "none"];
inline bool Record_PXY::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_PXY::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_PXY::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_PXY::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_PXY::name() const {
  return *name_;
}
inline void Record_PXY::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PXY::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PXY::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_PXY::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_PXY::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_PXY::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated double x = 2 [packed = true];
inline int Record_PXY::x_size() const {
  return x_.size();
}
inline void Record_PXY::clear_x() {
  x_.Clear();
}
inline double Record_PXY::x(int index) const {
  return x_.Get(index);
}
inline void Record_PXY::set_x(int index, double value) {
  x_.Set(index, value);
}
inline void Record_PXY::add_x(double value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_PXY::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_PXY::mutable_x() {
  return &x_;
}

// repeated double y = 3 [packed = true];
inline int Record_PXY::y_size() const {
  return y_.size();
}
inline void Record_PXY::clear_y() {
  y_.Clear();
}
inline double Record_PXY::y(int index) const {
  return y_.Get(index);
}
inline void Record_PXY::set_y(int index, double value) {
  y_.Set(index, value);
}
inline void Record_PXY::add_y(double value) {
  y_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_PXY::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_PXY::mutable_y() {
  return &y_;
}

// -------------------------------------------------------------------

// Record_PXYZ

// required string name = 1 [default = "none"];
inline bool Record_PXYZ::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_PXYZ::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_PXYZ::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_PXYZ::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_PXYZ::name() const {
  return *name_;
}
inline void Record_PXYZ::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PXYZ::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PXYZ::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_PXYZ::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_PXYZ::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_PXYZ::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated double x = 2 [packed = true];
inline int Record_PXYZ::x_size() const {
  return x_.size();
}
inline void Record_PXYZ::clear_x() {
  x_.Clear();
}
inline double Record_PXYZ::x(int index) const {
  return x_.Get(index);
}
inline void Record_PXYZ::set_x(int index, double value) {
  x_.Set(index, value);
}
inline void Record_PXYZ::add_x(double value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_PXYZ::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_PXYZ::mutable_x() {
  return &x_;
}

// repeated double y = 3 [packed = true];
inline int Record_PXYZ::y_size() const {
  return y_.size();
}
inline void Record_PXYZ::clear_y() {
  y_.Clear();
}
inline double Record_PXYZ::y(int index) const {
  return y_.Get(index);
}
inline void Record_PXYZ::set_y(int index, double value) {
  y_.Set(index, value);
}
inline void Record_PXYZ::add_y(double value) {
  y_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_PXYZ::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_PXYZ::mutable_y() {
  return &y_;
}

// repeated double z = 4 [packed = true];
inline int Record_PXYZ::z_size() const {
  return z_.size();
}
inline void Record_PXYZ::clear_z() {
  z_.Clear();
}
inline double Record_PXYZ::z(int index) const {
  return z_.Get(index);
}
inline void Record_PXYZ::set_z(int index, double value) {
  z_.Set(index, value);
}
inline void Record_PXYZ::add_z(double value) {
  z_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_PXYZ::z() const {
  return z_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_PXYZ::mutable_z() {
  return &z_;
}

// -------------------------------------------------------------------

// Record_P1D

// required string name = 1 [default = "none"];
inline bool Record_P1D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_P1D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_P1D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_P1D::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_P1D::name() const {
  return *name_;
}
inline void Record_P1D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_P1D::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_P1D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_P1D::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_P1D::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_P1D::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated double x = 2 [packed = true];
inline int Record_P1D::x_size() const {
  return x_.size();
}
inline void Record_P1D::clear_x() {
  x_.Clear();
}
inline double Record_P1D::x(int index) const {
  return x_.Get(index);
}
inline void Record_P1D::set_x(int index, double value) {
  x_.Set(index, value);
}
inline void Record_P1D::add_x(double value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_x() {
  return &x_;
}

// repeated double y = 3 [packed = true];
inline int Record_P1D::y_size() const {
  return y_.size();
}
inline void Record_P1D::clear_y() {
  y_.Clear();
}
inline double Record_P1D::y(int index) const {
  return y_.Get(index);
}
inline void Record_P1D::set_y(int index, double value) {
  y_.Set(index, value);
}
inline void Record_P1D::add_y(double value) {
  y_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_y() {
  return &y_;
}

// repeated double xleft = 4 [packed = true];
inline int Record_P1D::xleft_size() const {
  return xleft_.size();
}
inline void Record_P1D::clear_xleft() {
  xleft_.Clear();
}
inline double Record_P1D::xleft(int index) const {
  return xleft_.Get(index);
}
inline void Record_P1D::set_xleft(int index, double value) {
  xleft_.Set(index, value);
}
inline void Record_P1D::add_xleft(double value) {
  xleft_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::xleft() const {
  return xleft_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_xleft() {
  return &xleft_;
}

// repeated double xright = 5 [packed = true];
inline int Record_P1D::xright_size() const {
  return xright_.size();
}
inline void Record_P1D::clear_xright() {
  xright_.Clear();
}
inline double Record_P1D::xright(int index) const {
  return xright_.Get(index);
}
inline void Record_P1D::set_xright(int index, double value) {
  xright_.Set(index, value);
}
inline void Record_P1D::add_xright(double value) {
  xright_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::xright() const {
  return xright_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_xright() {
  return &xright_;
}

// repeated double yupper = 6 [packed = true];
inline int Record_P1D::yupper_size() const {
  return yupper_.size();
}
inline void Record_P1D::clear_yupper() {
  yupper_.Clear();
}
inline double Record_P1D::yupper(int index) const {
  return yupper_.Get(index);
}
inline void Record_P1D::set_yupper(int index, double value) {
  yupper_.Set(index, value);
}
inline void Record_P1D::add_yupper(double value) {
  yupper_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::yupper() const {
  return yupper_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_yupper() {
  return &yupper_;
}

// repeated double ylower = 7 [packed = true];
inline int Record_P1D::ylower_size() const {
  return ylower_.size();
}
inline void Record_P1D::clear_ylower() {
  ylower_.Clear();
}
inline double Record_P1D::ylower(int index) const {
  return ylower_.Get(index);
}
inline void Record_P1D::set_ylower(int index, double value) {
  ylower_.Set(index, value);
}
inline void Record_P1D::add_ylower(double value) {
  ylower_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::ylower() const {
  return ylower_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_ylower() {
  return &ylower_;
}

// repeated double xsysleft = 8 [packed = true];
inline int Record_P1D::xsysleft_size() const {
  return xsysleft_.size();
}
inline void Record_P1D::clear_xsysleft() {
  xsysleft_.Clear();
}
inline double Record_P1D::xsysleft(int index) const {
  return xsysleft_.Get(index);
}
inline void Record_P1D::set_xsysleft(int index, double value) {
  xsysleft_.Set(index, value);
}
inline void Record_P1D::add_xsysleft(double value) {
  xsysleft_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::xsysleft() const {
  return xsysleft_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_xsysleft() {
  return &xsysleft_;
}

// repeated double xsysright = 9 [packed = true];
inline int Record_P1D::xsysright_size() const {
  return xsysright_.size();
}
inline void Record_P1D::clear_xsysright() {
  xsysright_.Clear();
}
inline double Record_P1D::xsysright(int index) const {
  return xsysright_.Get(index);
}
inline void Record_P1D::set_xsysright(int index, double value) {
  xsysright_.Set(index, value);
}
inline void Record_P1D::add_xsysright(double value) {
  xsysright_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::xsysright() const {
  return xsysright_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_xsysright() {
  return &xsysright_;
}

// repeated double ysysupper = 10 [packed = true];
inline int Record_P1D::ysysupper_size() const {
  return ysysupper_.size();
}
inline void Record_P1D::clear_ysysupper() {
  ysysupper_.Clear();
}
inline double Record_P1D::ysysupper(int index) const {
  return ysysupper_.Get(index);
}
inline void Record_P1D::set_ysysupper(int index, double value) {
  ysysupper_.Set(index, value);
}
inline void Record_P1D::add_ysysupper(double value) {
  ysysupper_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::ysysupper() const {
  return ysysupper_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_ysysupper() {
  return &ysysupper_;
}

// repeated double ysyslower = 11 [packed = true];
inline int Record_P1D::ysyslower_size() const {
  return ysyslower_.size();
}
inline void Record_P1D::clear_ysyslower() {
  ysyslower_.Clear();
}
inline double Record_P1D::ysyslower(int index) const {
  return ysyslower_.Get(index);
}
inline void Record_P1D::set_ysyslower(int index, double value) {
  ysyslower_.Set(index, value);
}
inline void Record_P1D::add_ysyslower(double value) {
  ysyslower_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_P1D::ysyslower() const {
  return ysyslower_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_P1D::mutable_ysyslower() {
  return &ysyslower_;
}

// -------------------------------------------------------------------

// Record_H1D

// required string name = 1 [default = "none"];
inline bool Record_H1D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_H1D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_H1D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_H1D::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_H1D::name() const {
  return *name_;
}
inline void Record_H1D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_H1D::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_H1D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_H1D::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_H1D::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_H1D::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated double heights = 2 [packed = true];
inline int Record_H1D::heights_size() const {
  return heights_.size();
}
inline void Record_H1D::clear_heights() {
  heights_.Clear();
}
inline double Record_H1D::heights(int index) const {
  return heights_.Get(index);
}
inline void Record_H1D::set_heights(int index, double value) {
  heights_.Set(index, value);
}
inline void Record_H1D::add_heights(double value) {
  heights_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H1D::heights() const {
  return heights_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H1D::mutable_heights() {
  return &heights_;
}

// repeated double errors = 3 [packed = true];
inline int Record_H1D::errors_size() const {
  return errors_.size();
}
inline void Record_H1D::clear_errors() {
  errors_.Clear();
}
inline double Record_H1D::errors(int index) const {
  return errors_.Get(index);
}
inline void Record_H1D::set_errors(int index, double value) {
  errors_.Set(index, value);
}
inline void Record_H1D::add_errors(double value) {
  errors_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H1D::errors() const {
  return errors_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H1D::mutable_errors() {
  return &errors_;
}

// repeated double means = 4 [packed = true];
inline int Record_H1D::means_size() const {
  return means_.size();
}
inline void Record_H1D::clear_means() {
  means_.Clear();
}
inline double Record_H1D::means(int index) const {
  return means_.Get(index);
}
inline void Record_H1D::set_means(int index, double value) {
  means_.Set(index, value);
}
inline void Record_H1D::add_means(double value) {
  means_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H1D::means() const {
  return means_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H1D::mutable_means() {
  return &means_;
}

// repeated double rmses = 5 [packed = true];
inline int Record_H1D::rmses_size() const {
  return rmses_.size();
}
inline void Record_H1D::clear_rmses() {
  rmses_.Clear();
}
inline double Record_H1D::rmses(int index) const {
  return rmses_.Get(index);
}
inline void Record_H1D::set_rmses(int index, double value) {
  rmses_.Set(index, value);
}
inline void Record_H1D::add_rmses(double value) {
  rmses_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H1D::rmses() const {
  return rmses_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H1D::mutable_rmses() {
  return &rmses_;
}

// repeated int32 entries = 6 [packed = true];
inline int Record_H1D::entries_size() const {
  return entries_.size();
}
inline void Record_H1D::clear_entries() {
  entries_.Clear();
}
inline ::google::protobuf::int32 Record_H1D::entries(int index) const {
  return entries_.Get(index);
}
inline void Record_H1D::set_entries(int index, ::google::protobuf::int32 value) {
  entries_.Set(index, value);
}
inline void Record_H1D::add_entries(::google::protobuf::int32 value) {
  entries_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Record_H1D::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Record_H1D::mutable_entries() {
  return &entries_;
}

// repeated double edges = 7 [packed = true];
inline int Record_H1D::edges_size() const {
  return edges_.size();
}
inline void Record_H1D::clear_edges() {
  edges_.Clear();
}
inline double Record_H1D::edges(int index) const {
  return edges_.Get(index);
}
inline void Record_H1D::set_edges(int index, double value) {
  edges_.Set(index, value);
}
inline void Record_H1D::add_edges(double value) {
  edges_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H1D::edges() const {
  return edges_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H1D::mutable_edges() {
  return &edges_;
}

// required int32 bins = 8;
inline bool Record_H1D::has_bins() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Record_H1D::set_has_bins() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Record_H1D::clear_has_bins() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Record_H1D::clear_bins() {
  bins_ = 0;
  clear_has_bins();
}
inline ::google::protobuf::int32 Record_H1D::bins() const {
  return bins_;
}
inline void Record_H1D::set_bins(::google::protobuf::int32 value) {
  set_has_bins();
  bins_ = value;
}

// required double min = 9;
inline bool Record_H1D::has_min() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Record_H1D::set_has_min() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Record_H1D::clear_has_min() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Record_H1D::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline double Record_H1D::min() const {
  return min_;
}
inline void Record_H1D::set_min(double value) {
  set_has_min();
  min_ = value;
}

// required double max = 10;
inline bool Record_H1D::has_max() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Record_H1D::set_has_max() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Record_H1D::clear_has_max() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Record_H1D::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline double Record_H1D::max() const {
  return max_;
}
inline void Record_H1D::set_max(double value) {
  set_has_max();
  max_ = value;
}

// optional int32 allentries = 11;
inline bool Record_H1D::has_allentries() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Record_H1D::set_has_allentries() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Record_H1D::clear_has_allentries() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Record_H1D::clear_allentries() {
  allentries_ = 0;
  clear_has_allentries();
}
inline ::google::protobuf::int32 Record_H1D::allentries() const {
  return allentries_;
}
inline void Record_H1D::set_allentries(::google::protobuf::int32 value) {
  set_has_allentries();
  allentries_ = value;
}

// optional int32 nentries = 12;
inline bool Record_H1D::has_nentries() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Record_H1D::set_has_nentries() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Record_H1D::clear_has_nentries() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Record_H1D::clear_nentries() {
  nentries_ = 0;
  clear_has_nentries();
}
inline ::google::protobuf::int32 Record_H1D::nentries() const {
  return nentries_;
}
inline void Record_H1D::set_nentries(::google::protobuf::int32 value) {
  set_has_nentries();
  nentries_ = value;
}

// optional double underflow = 13;
inline bool Record_H1D::has_underflow() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Record_H1D::set_has_underflow() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Record_H1D::clear_has_underflow() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Record_H1D::clear_underflow() {
  underflow_ = 0;
  clear_has_underflow();
}
inline double Record_H1D::underflow() const {
  return underflow_;
}
inline void Record_H1D::set_underflow(double value) {
  set_has_underflow();
  underflow_ = value;
}

// optional double overflow = 14;
inline bool Record_H1D::has_overflow() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Record_H1D::set_has_overflow() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Record_H1D::clear_has_overflow() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Record_H1D::clear_overflow() {
  overflow_ = 0;
  clear_has_overflow();
}
inline double Record_H1D::overflow() const {
  return overflow_;
}
inline void Record_H1D::set_overflow(double value) {
  set_has_overflow();
  overflow_ = value;
}

// optional double rms = 15;
inline bool Record_H1D::has_rms() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Record_H1D::set_has_rms() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Record_H1D::clear_has_rms() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Record_H1D::clear_rms() {
  rms_ = 0;
  clear_has_rms();
}
inline double Record_H1D::rms() const {
  return rms_;
}
inline void Record_H1D::set_rms(double value) {
  set_has_rms();
  rms_ = value;
}

// optional double mean = 16;
inline bool Record_H1D::has_mean() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Record_H1D::set_has_mean() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Record_H1D::clear_has_mean() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Record_H1D::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline double Record_H1D::mean() const {
  return mean_;
}
inline void Record_H1D::set_mean(double value) {
  set_has_mean();
  mean_ = value;
}

// required bool isFixedBins = 17;
inline bool Record_H1D::has_isfixedbins() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Record_H1D::set_has_isfixedbins() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Record_H1D::clear_has_isfixedbins() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Record_H1D::clear_isfixedbins() {
  isfixedbins_ = false;
  clear_has_isfixedbins();
}
inline bool Record_H1D::isfixedbins() const {
  return isfixedbins_;
}
inline void Record_H1D::set_isfixedbins(bool value) {
  set_has_isfixedbins();
  isfixedbins_ = value;
}

// -------------------------------------------------------------------

// Record_H2D

// required string name = 1 [default = "none"];
inline bool Record_H2D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_H2D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_H2D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_H2D::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_H2D::name() const {
  return *name_;
}
inline void Record_H2D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_H2D::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_H2D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_H2D::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_H2D::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_H2D::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated double heights = 2 [packed = true];
inline int Record_H2D::heights_size() const {
  return heights_.size();
}
inline void Record_H2D::clear_heights() {
  heights_.Clear();
}
inline double Record_H2D::heights(int index) const {
  return heights_.Get(index);
}
inline void Record_H2D::set_heights(int index, double value) {
  heights_.Set(index, value);
}
inline void Record_H2D::add_heights(double value) {
  heights_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::heights() const {
  return heights_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_heights() {
  return &heights_;
}

// repeated double errors = 3 [packed = true];
inline int Record_H2D::errors_size() const {
  return errors_.size();
}
inline void Record_H2D::clear_errors() {
  errors_.Clear();
}
inline double Record_H2D::errors(int index) const {
  return errors_.Get(index);
}
inline void Record_H2D::set_errors(int index, double value) {
  errors_.Set(index, value);
}
inline void Record_H2D::add_errors(double value) {
  errors_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::errors() const {
  return errors_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_errors() {
  return &errors_;
}

// repeated double meansX = 4 [packed = true];
inline int Record_H2D::meansx_size() const {
  return meansx_.size();
}
inline void Record_H2D::clear_meansx() {
  meansx_.Clear();
}
inline double Record_H2D::meansx(int index) const {
  return meansx_.Get(index);
}
inline void Record_H2D::set_meansx(int index, double value) {
  meansx_.Set(index, value);
}
inline void Record_H2D::add_meansx(double value) {
  meansx_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::meansx() const {
  return meansx_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_meansx() {
  return &meansx_;
}

// repeated double rmsesX = 5 [packed = true];
inline int Record_H2D::rmsesx_size() const {
  return rmsesx_.size();
}
inline void Record_H2D::clear_rmsesx() {
  rmsesx_.Clear();
}
inline double Record_H2D::rmsesx(int index) const {
  return rmsesx_.Get(index);
}
inline void Record_H2D::set_rmsesx(int index, double value) {
  rmsesx_.Set(index, value);
}
inline void Record_H2D::add_rmsesx(double value) {
  rmsesx_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::rmsesx() const {
  return rmsesx_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_rmsesx() {
  return &rmsesx_;
}

// repeated int32 entries = 6 [packed = true];
inline int Record_H2D::entries_size() const {
  return entries_.size();
}
inline void Record_H2D::clear_entries() {
  entries_.Clear();
}
inline ::google::protobuf::int32 Record_H2D::entries(int index) const {
  return entries_.Get(index);
}
inline void Record_H2D::set_entries(int index, ::google::protobuf::int32 value) {
  entries_.Set(index, value);
}
inline void Record_H2D::add_entries(::google::protobuf::int32 value) {
  entries_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Record_H2D::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Record_H2D::mutable_entries() {
  return &entries_;
}

// repeated double meansY = 7 [packed = true];
inline int Record_H2D::meansy_size() const {
  return meansy_.size();
}
inline void Record_H2D::clear_meansy() {
  meansy_.Clear();
}
inline double Record_H2D::meansy(int index) const {
  return meansy_.Get(index);
}
inline void Record_H2D::set_meansy(int index, double value) {
  meansy_.Set(index, value);
}
inline void Record_H2D::add_meansy(double value) {
  meansy_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::meansy() const {
  return meansy_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_meansy() {
  return &meansy_;
}

// repeated double rmsesY = 8 [packed = true];
inline int Record_H2D::rmsesy_size() const {
  return rmsesy_.size();
}
inline void Record_H2D::clear_rmsesy() {
  rmsesy_.Clear();
}
inline double Record_H2D::rmsesy(int index) const {
  return rmsesy_.Get(index);
}
inline void Record_H2D::set_rmsesy(int index, double value) {
  rmsesy_.Set(index, value);
}
inline void Record_H2D::add_rmsesy(double value) {
  rmsesy_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::rmsesy() const {
  return rmsesy_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_rmsesy() {
  return &rmsesy_;
}

// repeated double summary = 9 [packed = true];
inline int Record_H2D::summary_size() const {
  return summary_.size();
}
inline void Record_H2D::clear_summary() {
  summary_.Clear();
}
inline double Record_H2D::summary(int index) const {
  return summary_.Get(index);
}
inline void Record_H2D::set_summary(int index, double value) {
  summary_.Set(index, value);
}
inline void Record_H2D::add_summary(double value) {
  summary_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::summary() const {
  return summary_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_summary() {
  return &summary_;
}

// repeated double outofrange = 10 [packed = true];
inline int Record_H2D::outofrange_size() const {
  return outofrange_.size();
}
inline void Record_H2D::clear_outofrange() {
  outofrange_.Clear();
}
inline double Record_H2D::outofrange(int index) const {
  return outofrange_.Get(index);
}
inline void Record_H2D::set_outofrange(int index, double value) {
  outofrange_.Set(index, value);
}
inline void Record_H2D::add_outofrange(double value) {
  outofrange_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_H2D::outofrange() const {
  return outofrange_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_H2D::mutable_outofrange() {
  return &outofrange_;
}

// optional int32 allentries = 11;
inline bool Record_H2D::has_allentries() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Record_H2D::set_has_allentries() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Record_H2D::clear_has_allentries() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Record_H2D::clear_allentries() {
  allentries_ = 0;
  clear_has_allentries();
}
inline ::google::protobuf::int32 Record_H2D::allentries() const {
  return allentries_;
}
inline void Record_H2D::set_allentries(::google::protobuf::int32 value) {
  set_has_allentries();
  allentries_ = value;
}

// optional int32 nentries = 12;
inline bool Record_H2D::has_nentries() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Record_H2D::set_has_nentries() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Record_H2D::clear_has_nentries() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Record_H2D::clear_nentries() {
  nentries_ = 0;
  clear_has_nentries();
}
inline ::google::protobuf::int32 Record_H2D::nentries() const {
  return nentries_;
}
inline void Record_H2D::set_nentries(::google::protobuf::int32 value) {
  set_has_nentries();
  nentries_ = value;
}

// required bool isFixedBins = 13;
inline bool Record_H2D::has_isfixedbins() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Record_H2D::set_has_isfixedbins() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Record_H2D::clear_has_isfixedbins() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Record_H2D::clear_isfixedbins() {
  isfixedbins_ = false;
  clear_has_isfixedbins();
}
inline bool Record_H2D::isfixedbins() const {
  return isfixedbins_;
}
inline void Record_H2D::set_isfixedbins(bool value) {
  set_has_isfixedbins();
  isfixedbins_ = value;
}

// -------------------------------------------------------------------

// Record_F1D

// required string name = 1 [default = "none"];
inline bool Record_F1D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_F1D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_F1D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_F1D::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_F1D::name() const {
  return *name_;
}
inline void Record_F1D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_F1D::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_F1D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_F1D::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_F1D::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_F1D::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required string definition = 2;
inline bool Record_F1D::has_definition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record_F1D::set_has_definition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record_F1D::clear_has_definition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record_F1D::clear_definition() {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    definition_->clear();
  }
  clear_has_definition();
}
inline const ::std::string& Record_F1D::definition() const {
  return *definition_;
}
inline void Record_F1D::set_definition(const ::std::string& value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_F1D::set_definition(const char* value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_F1D::set_definition(const char* value, size_t size) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_F1D::mutable_definition() {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  return definition_;
}
inline ::std::string* Record_F1D::release_definition() {
  clear_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = definition_;
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record_F1D::set_allocated_definition(::std::string* definition) {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    delete definition_;
  }
  if (definition) {
    set_has_definition();
    definition_ = definition;
  } else {
    clear_has_definition();
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double min = 3;
inline bool Record_F1D::has_min() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record_F1D::set_has_min() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record_F1D::clear_has_min() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record_F1D::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline double Record_F1D::min() const {
  return min_;
}
inline void Record_F1D::set_min(double value) {
  set_has_min();
  min_ = value;
}

// optional double max = 4;
inline bool Record_F1D::has_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Record_F1D::set_has_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Record_F1D::clear_has_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Record_F1D::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline double Record_F1D::max() const {
  return max_;
}
inline void Record_F1D::set_max(double value) {
  set_has_max();
  max_ = value;
}

// -------------------------------------------------------------------

// Record_F2D

// required string name = 1 [default = "none"];
inline bool Record_F2D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_F2D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_F2D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_F2D::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_F2D::name() const {
  return *name_;
}
inline void Record_F2D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_F2D::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_F2D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_F2D::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_F2D::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_F2D::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required string definition = 2;
inline bool Record_F2D::has_definition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record_F2D::set_has_definition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record_F2D::clear_has_definition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record_F2D::clear_definition() {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    definition_->clear();
  }
  clear_has_definition();
}
inline const ::std::string& Record_F2D::definition() const {
  return *definition_;
}
inline void Record_F2D::set_definition(const ::std::string& value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_F2D::set_definition(const char* value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_F2D::set_definition(const char* value, size_t size) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_F2D::mutable_definition() {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  return definition_;
}
inline ::std::string* Record_F2D::release_definition() {
  clear_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = definition_;
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record_F2D::set_allocated_definition(::std::string* definition) {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    delete definition_;
  }
  if (definition) {
    set_has_definition();
    definition_ = definition;
  } else {
    clear_has_definition();
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double minX = 3;
inline bool Record_F2D::has_minx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record_F2D::set_has_minx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record_F2D::clear_has_minx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record_F2D::clear_minx() {
  minx_ = 0;
  clear_has_minx();
}
inline double Record_F2D::minx() const {
  return minx_;
}
inline void Record_F2D::set_minx(double value) {
  set_has_minx();
  minx_ = value;
}

// optional double maxX = 4;
inline bool Record_F2D::has_maxx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Record_F2D::set_has_maxx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Record_F2D::clear_has_maxx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Record_F2D::clear_maxx() {
  maxx_ = 0;
  clear_has_maxx();
}
inline double Record_F2D::maxx() const {
  return maxx_;
}
inline void Record_F2D::set_maxx(double value) {
  set_has_maxx();
  maxx_ = value;
}

// optional double minY = 5;
inline bool Record_F2D::has_miny() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Record_F2D::set_has_miny() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Record_F2D::clear_has_miny() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Record_F2D::clear_miny() {
  miny_ = 0;
  clear_has_miny();
}
inline double Record_F2D::miny() const {
  return miny_;
}
inline void Record_F2D::set_miny(double value) {
  set_has_miny();
  miny_ = value;
}

// optional double maxY = 6;
inline bool Record_F2D::has_maxy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Record_F2D::set_has_maxy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Record_F2D::clear_has_maxy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Record_F2D::clear_maxy() {
  maxy_ = 0;
  clear_has_maxy();
}
inline double Record_F2D::maxy() const {
  return maxy_;
}
inline void Record_F2D::set_maxy(double value) {
  set_has_maxy();
  maxy_ = value;
}

// -------------------------------------------------------------------

// Record_FND

// required string name = 1 [default = "none"];
inline bool Record_FND::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_FND::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_FND::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_FND::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_FND::name() const {
  return *name_;
}
inline void Record_FND::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_FND::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_FND::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_FND::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_FND::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_FND::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required string definition = 2;
inline bool Record_FND::has_definition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record_FND::set_has_definition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record_FND::clear_has_definition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record_FND::clear_definition() {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    definition_->clear();
  }
  clear_has_definition();
}
inline const ::std::string& Record_FND::definition() const {
  return *definition_;
}
inline void Record_FND::set_definition(const ::std::string& value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_FND::set_definition(const char* value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_FND::set_definition(const char* value, size_t size) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_FND::mutable_definition() {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  return definition_;
}
inline ::std::string* Record_FND::release_definition() {
  clear_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = definition_;
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record_FND::set_allocated_definition(::std::string* definition) {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    delete definition_;
  }
  if (definition) {
    set_has_definition();
    definition_ = definition;
  } else {
    clear_has_definition();
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string vars = 3;
inline bool Record_FND::has_vars() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record_FND::set_has_vars() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record_FND::clear_has_vars() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record_FND::clear_vars() {
  if (vars_ != &::google::protobuf::internal::kEmptyString) {
    vars_->clear();
  }
  clear_has_vars();
}
inline const ::std::string& Record_FND::vars() const {
  return *vars_;
}
inline void Record_FND::set_vars(const ::std::string& value) {
  set_has_vars();
  if (vars_ == &::google::protobuf::internal::kEmptyString) {
    vars_ = new ::std::string;
  }
  vars_->assign(value);
}
inline void Record_FND::set_vars(const char* value) {
  set_has_vars();
  if (vars_ == &::google::protobuf::internal::kEmptyString) {
    vars_ = new ::std::string;
  }
  vars_->assign(value);
}
inline void Record_FND::set_vars(const char* value, size_t size) {
  set_has_vars();
  if (vars_ == &::google::protobuf::internal::kEmptyString) {
    vars_ = new ::std::string;
  }
  vars_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_FND::mutable_vars() {
  set_has_vars();
  if (vars_ == &::google::protobuf::internal::kEmptyString) {
    vars_ = new ::std::string;
  }
  return vars_;
}
inline ::std::string* Record_FND::release_vars() {
  clear_has_vars();
  if (vars_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vars_;
    vars_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record_FND::set_allocated_vars(::std::string* vars) {
  if (vars_ != &::google::protobuf::internal::kEmptyString) {
    delete vars_;
  }
  if (vars) {
    set_has_vars();
    vars_ = vars;
  } else {
    clear_has_vars();
    vars_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Record_FPR

// required string name = 1 [default = "none"];
inline bool Record_FPR::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_FPR::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_FPR::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_FPR::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_FPR::name() const {
  return *name_;
}
inline void Record_FPR::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_FPR::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_FPR::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_FPR::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_FPR::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_FPR::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required string definition = 2;
inline bool Record_FPR::has_definition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record_FPR::set_has_definition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record_FPR::clear_has_definition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record_FPR::clear_definition() {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    definition_->clear();
  }
  clear_has_definition();
}
inline const ::std::string& Record_FPR::definition() const {
  return *definition_;
}
inline void Record_FPR::set_definition(const ::std::string& value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_FPR::set_definition(const char* value) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(value);
}
inline void Record_FPR::set_definition(const char* value, size_t size) {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  definition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_FPR::mutable_definition() {
  set_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    definition_ = new ::std::string;
  }
  return definition_;
}
inline ::std::string* Record_FPR::release_definition() {
  clear_has_definition();
  if (definition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = definition_;
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record_FPR::set_allocated_definition(::std::string* definition) {
  if (definition_ != &::google::protobuf::internal::kEmptyString) {
    delete definition_;
  }
  if (definition) {
    set_has_definition();
    definition_ = definition;
  } else {
    clear_has_definition();
    definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 divU = 3;
inline bool Record_FPR::has_divu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record_FPR::set_has_divu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record_FPR::clear_has_divu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record_FPR::clear_divu() {
  divu_ = 0;
  clear_has_divu();
}
inline ::google::protobuf::int32 Record_FPR::divu() const {
  return divu_;
}
inline void Record_FPR::set_divu(::google::protobuf::int32 value) {
  set_has_divu();
  divu_ = value;
}

// required int32 divV = 4;
inline bool Record_FPR::has_divv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Record_FPR::set_has_divv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Record_FPR::clear_has_divv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Record_FPR::clear_divv() {
  divv_ = 0;
  clear_has_divv();
}
inline ::google::protobuf::int32 Record_FPR::divv() const {
  return divv_;
}
inline void Record_FPR::set_divv(::google::protobuf::int32 value) {
  set_has_divv();
  divv_ = value;
}

// -------------------------------------------------------------------

// Record_PND

// required string name = 1 [default = "none"];
inline bool Record_PND::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_PND::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_PND::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_PND::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_PND::name() const {
  return *name_;
}
inline void Record_PND::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PND::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PND::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_PND::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_PND::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_PND::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated double value = 2 [packed = true];
inline int Record_PND::value_size() const {
  return value_.size();
}
inline void Record_PND::clear_value() {
  value_.Clear();
}
inline double Record_PND::value(int index) const {
  return value_.Get(index);
}
inline void Record_PND::set_value(int index, double value) {
  value_.Set(index, value);
}
inline void Record_PND::add_value(double value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Record_PND::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
Record_PND::mutable_value() {
  return &value_;
}

// required int32 dimension = 3;
inline bool Record_PND::has_dimension() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record_PND::set_has_dimension() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record_PND::clear_has_dimension() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record_PND::clear_dimension() {
  dimension_ = 0;
  clear_has_dimension();
}
inline ::google::protobuf::int32 Record_PND::dimension() const {
  return dimension_;
}
inline void Record_PND::set_dimension(::google::protobuf::int32 value) {
  set_has_dimension();
  dimension_ = value;
}

// -------------------------------------------------------------------

// Record_PNI

// required string name = 1 [default = "none"];
inline bool Record_PNI::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record_PNI::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record_PNI::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record_PNI::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Record_PNI::name() const {
  return *name_;
}
inline void Record_PNI::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PNI::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record_PNI::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record_PNI::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Record_PNI::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Record_PNI::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated int32 value = 2 [packed = true];
inline int Record_PNI::value_size() const {
  return value_.size();
}
inline void Record_PNI::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int32 Record_PNI::value(int index) const {
  return value_.Get(index);
}
inline void Record_PNI::set_value(int index, ::google::protobuf::int32 value) {
  value_.Set(index, value);
}
inline void Record_PNI::add_value(::google::protobuf::int32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Record_PNI::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Record_PNI::mutable_value() {
  return &value_;
}

// required int32 dimension = 3;
inline bool Record_PNI::has_dimension() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record_PNI::set_has_dimension() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record_PNI::clear_has_dimension() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record_PNI::clear_dimension() {
  dimension_ = 0;
  clear_has_dimension();
}
inline ::google::protobuf::int32 Record_PNI::dimension() const {
  return dimension_;
}
inline void Record_PNI::set_dimension(::google::protobuf::int32 value) {
  set_has_dimension();
  dimension_ = value;
}

// -------------------------------------------------------------------

// Record

// optional string name = 1;
inline bool Record::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Record::name() const {
  return *name_;
}
inline void Record::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Record::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Record::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .promc.Record.P0I p0I = 2;
inline bool Record::has_p0i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record::set_has_p0i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record::clear_has_p0i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record::clear_p0i() {
  if (p0i_ != NULL) p0i_->::promc::Record_P0I::Clear();
  clear_has_p0i();
}
inline const ::promc::Record_P0I& Record::p0i() const {
  return p0i_ != NULL ? *p0i_ : *default_instance_->p0i_;
}
inline ::promc::Record_P0I* Record::mutable_p0i() {
  set_has_p0i();
  if (p0i_ == NULL) p0i_ = new ::promc::Record_P0I;
  return p0i_;
}
inline ::promc::Record_P0I* Record::release_p0i() {
  clear_has_p0i();
  ::promc::Record_P0I* temp = p0i_;
  p0i_ = NULL;
  return temp;
}
inline void Record::set_allocated_p0i(::promc::Record_P0I* p0i) {
  delete p0i_;
  p0i_ = p0i;
  if (p0i) {
    set_has_p0i();
  } else {
    clear_has_p0i();
  }
}

// optional .promc.Record.P0D p0D = 3;
inline bool Record::has_p0d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record::set_has_p0d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record::clear_has_p0d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record::clear_p0d() {
  if (p0d_ != NULL) p0d_->::promc::Record_P0D::Clear();
  clear_has_p0d();
}
inline const ::promc::Record_P0D& Record::p0d() const {
  return p0d_ != NULL ? *p0d_ : *default_instance_->p0d_;
}
inline ::promc::Record_P0D* Record::mutable_p0d() {
  set_has_p0d();
  if (p0d_ == NULL) p0d_ = new ::promc::Record_P0D;
  return p0d_;
}
inline ::promc::Record_P0D* Record::release_p0d() {
  clear_has_p0d();
  ::promc::Record_P0D* temp = p0d_;
  p0d_ = NULL;
  return temp;
}
inline void Record::set_allocated_p0d(::promc::Record_P0D* p0d) {
  delete p0d_;
  p0d_ = p0d;
  if (p0d) {
    set_has_p0d();
  } else {
    clear_has_p0d();
  }
}

// optional .promc.Record.PXY pXY = 4;
inline bool Record::has_pxy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Record::set_has_pxy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Record::clear_has_pxy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Record::clear_pxy() {
  if (pxy_ != NULL) pxy_->::promc::Record_PXY::Clear();
  clear_has_pxy();
}
inline const ::promc::Record_PXY& Record::pxy() const {
  return pxy_ != NULL ? *pxy_ : *default_instance_->pxy_;
}
inline ::promc::Record_PXY* Record::mutable_pxy() {
  set_has_pxy();
  if (pxy_ == NULL) pxy_ = new ::promc::Record_PXY;
  return pxy_;
}
inline ::promc::Record_PXY* Record::release_pxy() {
  clear_has_pxy();
  ::promc::Record_PXY* temp = pxy_;
  pxy_ = NULL;
  return temp;
}
inline void Record::set_allocated_pxy(::promc::Record_PXY* pxy) {
  delete pxy_;
  pxy_ = pxy;
  if (pxy) {
    set_has_pxy();
  } else {
    clear_has_pxy();
  }
}

// optional .promc.Record.PXYZ pXYZ = 5;
inline bool Record::has_pxyz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Record::set_has_pxyz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Record::clear_has_pxyz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Record::clear_pxyz() {
  if (pxyz_ != NULL) pxyz_->::promc::Record_PXYZ::Clear();
  clear_has_pxyz();
}
inline const ::promc::Record_PXYZ& Record::pxyz() const {
  return pxyz_ != NULL ? *pxyz_ : *default_instance_->pxyz_;
}
inline ::promc::Record_PXYZ* Record::mutable_pxyz() {
  set_has_pxyz();
  if (pxyz_ == NULL) pxyz_ = new ::promc::Record_PXYZ;
  return pxyz_;
}
inline ::promc::Record_PXYZ* Record::release_pxyz() {
  clear_has_pxyz();
  ::promc::Record_PXYZ* temp = pxyz_;
  pxyz_ = NULL;
  return temp;
}
inline void Record::set_allocated_pxyz(::promc::Record_PXYZ* pxyz) {
  delete pxyz_;
  pxyz_ = pxyz;
  if (pxyz) {
    set_has_pxyz();
  } else {
    clear_has_pxyz();
  }
}

// optional .promc.Record.P1D p1D = 6;
inline bool Record::has_p1d() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Record::set_has_p1d() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Record::clear_has_p1d() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Record::clear_p1d() {
  if (p1d_ != NULL) p1d_->::promc::Record_P1D::Clear();
  clear_has_p1d();
}
inline const ::promc::Record_P1D& Record::p1d() const {
  return p1d_ != NULL ? *p1d_ : *default_instance_->p1d_;
}
inline ::promc::Record_P1D* Record::mutable_p1d() {
  set_has_p1d();
  if (p1d_ == NULL) p1d_ = new ::promc::Record_P1D;
  return p1d_;
}
inline ::promc::Record_P1D* Record::release_p1d() {
  clear_has_p1d();
  ::promc::Record_P1D* temp = p1d_;
  p1d_ = NULL;
  return temp;
}
inline void Record::set_allocated_p1d(::promc::Record_P1D* p1d) {
  delete p1d_;
  p1d_ = p1d;
  if (p1d) {
    set_has_p1d();
  } else {
    clear_has_p1d();
  }
}

// optional .promc.Record.H1D h1D = 7;
inline bool Record::has_h1d() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Record::set_has_h1d() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Record::clear_has_h1d() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Record::clear_h1d() {
  if (h1d_ != NULL) h1d_->::promc::Record_H1D::Clear();
  clear_has_h1d();
}
inline const ::promc::Record_H1D& Record::h1d() const {
  return h1d_ != NULL ? *h1d_ : *default_instance_->h1d_;
}
inline ::promc::Record_H1D* Record::mutable_h1d() {
  set_has_h1d();
  if (h1d_ == NULL) h1d_ = new ::promc::Record_H1D;
  return h1d_;
}
inline ::promc::Record_H1D* Record::release_h1d() {
  clear_has_h1d();
  ::promc::Record_H1D* temp = h1d_;
  h1d_ = NULL;
  return temp;
}
inline void Record::set_allocated_h1d(::promc::Record_H1D* h1d) {
  delete h1d_;
  h1d_ = h1d;
  if (h1d) {
    set_has_h1d();
  } else {
    clear_has_h1d();
  }
}

// optional .promc.Record.H2D h2D = 8;
inline bool Record::has_h2d() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Record::set_has_h2d() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Record::clear_has_h2d() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Record::clear_h2d() {
  if (h2d_ != NULL) h2d_->::promc::Record_H2D::Clear();
  clear_has_h2d();
}
inline const ::promc::Record_H2D& Record::h2d() const {
  return h2d_ != NULL ? *h2d_ : *default_instance_->h2d_;
}
inline ::promc::Record_H2D* Record::mutable_h2d() {
  set_has_h2d();
  if (h2d_ == NULL) h2d_ = new ::promc::Record_H2D;
  return h2d_;
}
inline ::promc::Record_H2D* Record::release_h2d() {
  clear_has_h2d();
  ::promc::Record_H2D* temp = h2d_;
  h2d_ = NULL;
  return temp;
}
inline void Record::set_allocated_h2d(::promc::Record_H2D* h2d) {
  delete h2d_;
  h2d_ = h2d;
  if (h2d) {
    set_has_h2d();
  } else {
    clear_has_h2d();
  }
}

// optional .promc.Record.F1D f1D = 9;
inline bool Record::has_f1d() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Record::set_has_f1d() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Record::clear_has_f1d() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Record::clear_f1d() {
  if (f1d_ != NULL) f1d_->::promc::Record_F1D::Clear();
  clear_has_f1d();
}
inline const ::promc::Record_F1D& Record::f1d() const {
  return f1d_ != NULL ? *f1d_ : *default_instance_->f1d_;
}
inline ::promc::Record_F1D* Record::mutable_f1d() {
  set_has_f1d();
  if (f1d_ == NULL) f1d_ = new ::promc::Record_F1D;
  return f1d_;
}
inline ::promc::Record_F1D* Record::release_f1d() {
  clear_has_f1d();
  ::promc::Record_F1D* temp = f1d_;
  f1d_ = NULL;
  return temp;
}
inline void Record::set_allocated_f1d(::promc::Record_F1D* f1d) {
  delete f1d_;
  f1d_ = f1d;
  if (f1d) {
    set_has_f1d();
  } else {
    clear_has_f1d();
  }
}

// optional .promc.Record.F2D f2D = 10;
inline bool Record::has_f2d() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Record::set_has_f2d() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Record::clear_has_f2d() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Record::clear_f2d() {
  if (f2d_ != NULL) f2d_->::promc::Record_F2D::Clear();
  clear_has_f2d();
}
inline const ::promc::Record_F2D& Record::f2d() const {
  return f2d_ != NULL ? *f2d_ : *default_instance_->f2d_;
}
inline ::promc::Record_F2D* Record::mutable_f2d() {
  set_has_f2d();
  if (f2d_ == NULL) f2d_ = new ::promc::Record_F2D;
  return f2d_;
}
inline ::promc::Record_F2D* Record::release_f2d() {
  clear_has_f2d();
  ::promc::Record_F2D* temp = f2d_;
  f2d_ = NULL;
  return temp;
}
inline void Record::set_allocated_f2d(::promc::Record_F2D* f2d) {
  delete f2d_;
  f2d_ = f2d;
  if (f2d) {
    set_has_f2d();
  } else {
    clear_has_f2d();
  }
}

// optional .promc.Record.FND fND = 11;
inline bool Record::has_fnd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Record::set_has_fnd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Record::clear_has_fnd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Record::clear_fnd() {
  if (fnd_ != NULL) fnd_->::promc::Record_FND::Clear();
  clear_has_fnd();
}
inline const ::promc::Record_FND& Record::fnd() const {
  return fnd_ != NULL ? *fnd_ : *default_instance_->fnd_;
}
inline ::promc::Record_FND* Record::mutable_fnd() {
  set_has_fnd();
  if (fnd_ == NULL) fnd_ = new ::promc::Record_FND;
  return fnd_;
}
inline ::promc::Record_FND* Record::release_fnd() {
  clear_has_fnd();
  ::promc::Record_FND* temp = fnd_;
  fnd_ = NULL;
  return temp;
}
inline void Record::set_allocated_fnd(::promc::Record_FND* fnd) {
  delete fnd_;
  fnd_ = fnd;
  if (fnd) {
    set_has_fnd();
  } else {
    clear_has_fnd();
  }
}

// optional .promc.Record.FPR fPR = 12;
inline bool Record::has_fpr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Record::set_has_fpr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Record::clear_has_fpr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Record::clear_fpr() {
  if (fpr_ != NULL) fpr_->::promc::Record_FPR::Clear();
  clear_has_fpr();
}
inline const ::promc::Record_FPR& Record::fpr() const {
  return fpr_ != NULL ? *fpr_ : *default_instance_->fpr_;
}
inline ::promc::Record_FPR* Record::mutable_fpr() {
  set_has_fpr();
  if (fpr_ == NULL) fpr_ = new ::promc::Record_FPR;
  return fpr_;
}
inline ::promc::Record_FPR* Record::release_fpr() {
  clear_has_fpr();
  ::promc::Record_FPR* temp = fpr_;
  fpr_ = NULL;
  return temp;
}
inline void Record::set_allocated_fpr(::promc::Record_FPR* fpr) {
  delete fpr_;
  fpr_ = fpr;
  if (fpr) {
    set_has_fpr();
  } else {
    clear_has_fpr();
  }
}

// optional .promc.Record.PND pND = 13;
inline bool Record::has_pnd() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Record::set_has_pnd() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Record::clear_has_pnd() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Record::clear_pnd() {
  if (pnd_ != NULL) pnd_->::promc::Record_PND::Clear();
  clear_has_pnd();
}
inline const ::promc::Record_PND& Record::pnd() const {
  return pnd_ != NULL ? *pnd_ : *default_instance_->pnd_;
}
inline ::promc::Record_PND* Record::mutable_pnd() {
  set_has_pnd();
  if (pnd_ == NULL) pnd_ = new ::promc::Record_PND;
  return pnd_;
}
inline ::promc::Record_PND* Record::release_pnd() {
  clear_has_pnd();
  ::promc::Record_PND* temp = pnd_;
  pnd_ = NULL;
  return temp;
}
inline void Record::set_allocated_pnd(::promc::Record_PND* pnd) {
  delete pnd_;
  pnd_ = pnd;
  if (pnd) {
    set_has_pnd();
  } else {
    clear_has_pnd();
  }
}

// optional .promc.Record.PNI pNI = 14;
inline bool Record::has_pni() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Record::set_has_pni() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Record::clear_has_pni() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Record::clear_pni() {
  if (pni_ != NULL) pni_->::promc::Record_PNI::Clear();
  clear_has_pni();
}
inline const ::promc::Record_PNI& Record::pni() const {
  return pni_ != NULL ? *pni_ : *default_instance_->pni_;
}
inline ::promc::Record_PNI* Record::mutable_pni() {
  set_has_pni();
  if (pni_ == NULL) pni_ = new ::promc::Record_PNI;
  return pni_;
}
inline ::promc::Record_PNI* Record::release_pni() {
  clear_has_pni();
  ::promc::Record_PNI* temp = pni_;
  pni_ = NULL;
  return temp;
}
inline void Record::set_allocated_pni(::promc::Record_PNI* pni) {
  delete pni_;
  pni_ = pni;
  if (pni) {
    set_has_pni();
  } else {
    clear_has_pni();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace promc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HRecord_2eproto__INCLUDED
