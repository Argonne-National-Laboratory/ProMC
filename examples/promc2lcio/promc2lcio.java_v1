
import java.io.*;
import java.util.*;
import static java.lang.Math.sqrt;

import hep.lcio.event.*;

import hep.lcio.implementation.event.*;
import hep.lcio.implementation.io.LCFactory;
import hep.physics.event.generator.GeneratorFactory;
import hep.physics.event.generator.MCEvent;
import hep.physics.particle.*;
import hep.physics.particle.properties.*;
import hep.physics.vec.BasicHep3Vector;
import hep.physics.vec.BasicHepLorentzVector;
import hep.physics.vec.Hep3Vector;
import hep.physics.vec.HepLorentzVector;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import hep.lcio.io.*;


import java.io.*;
import java.net.*;
import java.util.*;
import java.text.*;
import java.nio.file.*;
import proto.*;
import promc.io.*;
import hepsim.*;
import java.util.zip.*;

/**
 * Reads in ProMC output pair file and creates events in LCIO format.
 * The code is based on STDHEP convertors by Tony J. 
 * @author S.Chekanov (ANL) and Jeremy McCormick <jeremym@slac.stanford.edu>.  
 * @version 1.1
 */
public class promc2lcio
{

   private final static String detName = "NONE";
   private final static String ecalName = "NONE";
   private final static String tpcName = "NONE";
   private static GeneratorFactory factory = new GeneratorFactory();
   private static ParticlePropertyManager pman=new ParticlePropertyManager();
   private static  ParticlePropertyProvider ppp = pman.getParticlePropertyProvider();
   private static final double c_light = 2.99792458e+8;
   private static boolean haveWarned = true;

    public static void main(String args[]) throws IOException
    {
        // remind user of correct usage
        if (args.length < 1)
            usage();
        if (args.length == 1 && args[0].equals("-h"))
            usage();

         String surl = args[0].trim();
         FileMC promc = new  FileMC(surl,"r");

        String outputFile=args[0]+".lcio"; 
    
        File outFile = new File(outputFile);
        if (args.length > 1) { 
             outputFile=args[1].trim(); 
             outFile = new File(outputFile);
        }


        LCWriter lcWrt = LCFactory.getInstance().createLCWriter();

        if (outFile.exists()) {
                System.out.println("File exist! Exit run for " + outputFile + " ...");
                System.exit(1);
            } else {
            try
            {

                    lcWrt.open(outputFile);

            } catch (java.io.IOException ex)
            {
                System.err.println("Error opening file: " + outputFile);
                ex.printStackTrace();
                System.exit(1);
            }
        }

     DecimalFormat formatter = new DecimalFormat("0.#####E0");
     DecimalFormat formatter1 = new DecimalFormat("0.###E0");

     int oldPercentComplete = 0;




                long    version=promc.getVersion();
                String decription=promc.getDescription();
                long nev1=promc.getNEntries();
                long nev2=promc.getEvents();
                if (nev1 != nev2) {
                      HepSim.ErrorMessage("There is a problem with this file: inconsistent number of entries. The file was truncated!");
                      promc.close();
                      System.exit(1);
                }

                long nevent=nev1;
 
                // get description
                ProMCDescriptionFile.ProMCDescription desc = promc.fetchDescription();


                ProMCHeaderFile.ProMCHeader header = promc.getHeader();
                int unit = header.getMomentumUnit();
                int lunit = header.getLengthUnit();

                boolean isLog=true;
                if (promc.getLogfileTxt().indexOf("logfile")==-1) isLog=false;


                ProMCStatFile.ProMCStat stat = promc.getStat();
                System.out.println("File          = "+surl);
                String cross=formatter.format( stat.getCrossSectionAccumulated() );
                String error=formatter.format( stat.getCrossSectionErrorAccumulated()  );
                System.out.println("ProMC version = "+Long.toString(version));
                System.out.println("Last modified = "+promc.getLastModified());
                System.out.println("Description   = "+decription.replace("\n",""));
                System.out.println("Events        = "+Long.toString(nev1));
                if (promc.getRequestedEvents() >0) System.out.println("Requested     = "+Long.toString(promc.getRequestedEvents()));
                System.out.println("Sigma    (pb) = "+cross+" \u00B1 "+error );
                System.out.println("Lumi   (pb-1) = "+formatter.format(stat.getLuminosityAccumulated()));
                System.out.println("Varint units  = E:"+Integer.toString(unit)+" L:"+Integer.toString(lunit) );
                System.out.println("Log file:     = "+ promc.getLogfileTxt()  );


                  if (isLog==false)
                   System.err.println(HepSim.ANSI_YELLOW+"Warning: Log file \"logfile.txt\" was not attached!"+HepSim.ANSI_RESET);


         ILCRunHeader runHdr = new ILCRunHeader();
         runHdr.setRunNumber(1000);
         runHdr.setDetectorName(detName);
         runHdr.setDescription( decription.replace("\n",""));
         //runHdr.addActiveSubdetector(ecalName);
         //runHdr.addActiveSubdetector(tpcName);
         runHdr.getParameters().setValue("ProMC",version) ;

         float Fcross = Float.parseFloat(cross);
         float ERRcross = Float.parseFloat(error);
         float[] idx = { Fcross,ERRcross} ;
         runHdr.getParameters().setValues("cross_section_pb",idx) ;
         lcWrt.writeRunHeader(runHdr);



           for (int event=0; event<nevent; event++){


           ProMC.ProMCEvent ss = promc.read( event );
           ProMC.ProMCEvent.Event proev = ss.getEvent(); // event

          //  MCEvent mcevent=convert(promc.read( event ), unit, lunit);

            ILCEvent evt = new ILCEvent();
            evt.setRunNumber(1000);
            evt.setEventNumber(event);
            evt.setDetectorName(detName);
            evt.setWeight( proev.getWeight()  ) ;
            evt.setTimeStamp(0);
 
           // create and add some mc particles
           ILCCollection mcVec = new ILCCollection(LCIO.MCPARTICLE);
           ILCCollection mcpcoll = convertILCIO(ss, unit, lunit); 
           evt.addCollection(mcpcoll, LCIO.MCPARTICLE);

                
                   int percentComplete = (int)((double)event * 100 / nevent);
                   if(percentComplete % 5 == 0 && percentComplete > oldPercentComplete) {
                                System.out.println(Integer.toString(percentComplete) + "% complete");
                                oldPercentComplete = percentComplete;
                        }

                  

           //      evt.addCollection(mcVec, "MCParticle");


            // write the event to the file
            lcWrt.writeEvent(evt);

            // dump the event to the screen
            // LCTools.dumpEvent(evt);

            } // end loop over events





            lcWrt.close();
            promc.close();

        }


 /**
    * Convert from a ProMC to an MCEvent.
    * Useful when reading stdhep files.
    */
   public static MCEvent convert(ProMC.ProMCEvent ss, int unit, int lunit)
   {

      ProMC.ProMCEvent.Particles pa = ss.getParticles(); // true particles


                boolean energyM=false;
                boolean statusM=false;
                boolean m1M=false;
                boolean m2M=false;
                boolean d1M=false;
                boolean d2M=false;
                boolean mM=false;
                boolean xM=false;
                boolean yM=false;
                boolean zM=false;
                boolean tM=false;
                boolean bM=false;
                boolean idM=false;
                boolean pidM=false;
                boolean pxM=false;
                boolean pzM=false;
                boolean pyM=false;

                if (pa.getEnergyCount()>1) energyM=true;
                if (pa.getMassCount()>1) mM=true;
                if (pa.getStatusCount()>1) statusM=true;
                if (pa.getMother1Count()>1) m1M=true;
                if (pa.getMother2Count()>1) m2M=true;
                if (pa.getDaughter1Count()>1) d1M=true;
                if (pa.getDaughter2Count()>1) d2M=true;
                if (pa.getXCount()>1) xM=true;
                if (pa.getYCount()>1) yM=true;
                if (pa.getZCount()>1) zM=true;
                if (pa.getTCount()>1) tM=true;
                if (pa.getBarcodeCount()>1) bM=true;
                if (pa.getPdgIdCount()>1)   pidM=true;
                if (pa.getPxCount()>1)   pxM=true;
                if (pa.getPyCount()>1)   pyM=true;
                if (pa.getPzCount()>1)   pzM=true;
                if (pa.getIdCount()>1)       idM=true;


      MCEvent event = factory.createEvent(0, pa.getPxCount());
      int n =  pa.getPxCount();
      BasicParticle[] particle = new BasicParticle[n];
      for (int j=0; j<n; j++)
      {
       


                                int pid = 0;
                                if (pidM) pid=pa.getPdgId(j);

                                int status=0;
                                if (statusM) status = pa.getStatus(j);

                                double m =0;
                                if (mM) m=pa.getMass(j) / (double) unit;

                                double px = 0;
                                if (pxM) px=pa.getPx(j) / (double) unit;

                                double py = 0;
                                if (pyM) py=pa.getPy(j) / (double) unit;

                                double pz = 0;
                                if (pzM) pz=pa.getPz(j) / (double) unit;

                                double ee = 0;
                                // fix before v1.3  when energy was not stored   
                                if (energyM) ee = pa.getEnergy(j) / (double) unit;
                                else ee=Math.sqrt(px*px+py*py+pz*pz+m*m);

                                int m1=0;
                                if (m1M) m1=pa.getMother1(j);

                                int m2=0;
                                if (m2M) m2 = pa.getMother2(j);

                                int d1=0;
                                if (d1M) d1 = pa.getDaughter1(j);

                                int d2=0;
                                if (d2M) d2 = pa.getDaughter2(j);

                                int barcode=0;
                                if (bM) barcode = pa.getBarcode(j);


                                int id=0;
                                if (idM) id = pa.getId(j);

                                 double x=0;
                                 if (xM) x = pa.getX(j) / (double) lunit;

                                 double y=0;
                                 if (yM) y = pa.getY(j) / (double) lunit;

                                 double z=0;
                                 if (zM) z = pa.getZ(j) / (double) lunit;


                                 double t=0;
                                 if (tM) t = pa.getT(j) / (double) lunit;


         Hep3Vector origin = new BasicHep3Vector(x,y,z);
         Hep3Vector momentum = new BasicHep3Vector(px,py,pz);
         HepLorentzVector p = new BasicHepLorentzVector(ee,momentum);
         ParticleType type = ppp.get(pid);
         particle[j] = factory.createParticle(origin,p,type,status,t);
         particle[j].setMass(m);
      }


      // Deal with daughters
      for (int i=0; i<n; i++)
      {
        
      int d1=0;
      if (d1M) d1 = pa.getDaughter1(i);

      int d2=0;
      if (d2M) d2 = pa.getDaughter2(i);

         if (d1 <= 0) continue;
         for (int j=d1;j<d2;j++)
         {
            particle[i].addDaughter(particle[j]);
         }
      }
      event.put(MCEvent.MC_PARTICLES,Arrays.asList(particle));
      return event;
   }


 
 private static void checkAndAddDaughter(IMCParticle[] particle, List ancestors, int parentID, int childID)
   {
      if (parentID == childID)
         return; // Can't be parent of self
      Set ancestor = (Set) ancestors.get(childID);
      boolean added = ancestor.add(particle[parentID]);
      if (added)
         particle[parentID].addDaughter(particle[childID]);
   }
   
   private static int fillIndexVec(int[] vec, int idx1, int idx2)
   {
      int l = 0;
      try
      {
         if (idx1 >= 0 && idx2 >= 0)
         {
            if (idx1 < idx2)
            {
               for (int i = idx1; i < (idx2 + 1); i++)
               {
                  vec[l++] = i;
               }
            }
            else if (idx1 > idx2)
            {
               vec[l++] = idx1;
               vec[l++] = idx2;
            }
            // indices are equal
            else
            {
               vec[l++] = idx1;
            }
         }
         else if (idx1 >= 0)
         {
            vec[l++] = idx1;
         }
      }
      catch (ArrayIndexOutOfBoundsException x)
      {
         if (!haveWarned) System.err.println("Warning: Array index out of bounds exception caused by corrupt stdhep file ignored");
         haveWarned = true;
      }
      return l;
   }
   



   /**
    * Convert a StdhepEvent to an LCCollection of MCParticle objects.
    * @param hepevt The StdhepEvent to be converted.
    * @return An LCCollection of MCParticle objects converted from hepevt.
    */
   public static ILCCollection convertILCIO(ProMC.ProMCEvent ss, int unit, int lunit)
   {
               ILCCollection mcpcoll = new ILCCollection(LCIO.MCPARTICLE);
               ProMC.ProMCEvent.Particles pa = ss.getParticles(); // true particles


                boolean energyM=false;
                boolean statusM=false;
                boolean m1M=false;
                boolean m2M=false;
                boolean d1M=false;
                boolean d2M=false;
                boolean mM=false;
                boolean xM=false;
                boolean yM=false;
                boolean zM=false;
                boolean tM=false;
                boolean bM=false;
                boolean idM=false;
                boolean pidM=false;
                boolean pxM=false;
                boolean pzM=false;
                boolean pyM=false;

                if (pa.getEnergyCount()>1) energyM=true;
                if (pa.getMassCount()>1) mM=true;
                if (pa.getStatusCount()>1) statusM=true;
                if (pa.getMother1Count()>1) m1M=true;
                if (pa.getMother2Count()>1) m2M=true;
                if (pa.getDaughter1Count()>1) d1M=true;
                if (pa.getDaughter2Count()>1) d2M=true;
                if (pa.getXCount()>1) xM=true;
                if (pa.getYCount()>1) yM=true;
                if (pa.getZCount()>1) zM=true;
                if (pa.getTCount()>1) tM=true;
                if (pa.getBarcodeCount()>1) bM=true;
                if (pa.getPdgIdCount()>1)   pidM=true;
                if (pa.getPxCount()>1)   pxM=true;
                if (pa.getPyCount()>1)   pyM=true;
                if (pa.getPzCount()>1)   pzM=true;
                if (pa.getIdCount()>1)       idM=true;




      int n = pa.getPxCount();
      
      IMCParticle particles[] = new IMCParticle[n];
      
      for (int j = 0; j< n; j++)  {


                                 int pid = 0;
                                if (pidM) pid=pa.getPdgId(j);

                                int status=0;
                                if (statusM) status = pa.getStatus(j);

                                double m =0;
                                if (mM) m=pa.getMass(j) / (double) unit;

                                double px = 0;
                                if (pxM) px=pa.getPx(j) / (double) unit;

                                double py = 0;
                                if (pyM) py=pa.getPy(j) / (double) unit;

                                double pz = 0;
                                if (pzM) pz=pa.getPz(j) / (double) unit;

                                double ee = 0;
                                // fix before v1.3  when energy was not stored   
                                if (energyM) ee = pa.getEnergy(j) / (double) unit;
                                else ee=Math.sqrt(px*px+py*py+pz*pz+m*m);

                                int m1=0;
                                if (m1M) m1=pa.getMother1(j);

                                int m2=0;
                                if (m2M) m2 = pa.getMother2(j);

                                int d1=0;
                                if (d1M) d1 = pa.getDaughter1(j);

                                int d2=0;
                                if (d2M) d2 = pa.getDaughter2(j);

                                int barcode=0;
                                if (bM) barcode = pa.getBarcode(j);


                                int id=0;
                                if (idM) id = pa.getId(j);

                                 double x=0;
                                 if (xM) x = pa.getX(j) / (double) lunit;

                                 double y=0;
                                 if (yM) y = pa.getY(j) / (double) lunit;

                                 double z=0;
                                 if (zM) z = pa.getZ(j) / (double) lunit;


                                 double t=0;
                                 if (tM) t = pa.getT(j) / (double) lunit;















         // Create new MCParticle for this Stdhep record.
         IMCParticle particle = new IMCParticle();
         
         // Set vertex from VHEP.
         double vertex[] = { x, y, z };
         particle.setVertex(vertex);
         
         // Set momentum from PHEP.
         double momentum[] ={px,py,pz };
         particle.setMomentum(momentum);
         
         // Lookup the particle by PDG using the Particle Property Provider.
         ParticleType type;
         try
         {
            // Get the particle type.
            type = ppp.get(pid);
            // Set the charge.
            particle.setCharge((float) type.getCharge());
         }
         catch (UnknownParticleIDException e)
         {
            // Flag the particle with NaN for unknown charge.
            particle.setCharge(Float.NaN);
         }
         
         // Set mass from PHEP.
         particle.setMass((float)m);
         
         // Set PDG from IDHEP.
         particle.setPDG(pid);
/*
0 empty line
1 undecayed particle, stable in the generator
2 particle decayed in the generator
3 documentation line
*/
 
         //if (status !=1) status=2;
         //if (pid == 90)  status=3;  // Pythia8
         particle.setGeneratorStatus( status ) ;
         
         // Set time from VHEP(4).
         // Convert to mm/c^2 from mm/c, as in slic/StdHepToLcioConvertor .
         particle.setTime((float)(t / c_light));

         // Add MCParticle to the temp array.
         particles[j] = particle;

      }
      
      int[] vec = new int[n];
      //List<Set<BasicParticle>> ancestors = new ArrayList<Set<BasicParticle>>(n);
      List ancestors = new ArrayList();
      for (int i = 0; i < n; i++)
         ancestors.add(new HashSet());
      // Deal with parents
      for (int i = 0; i < n; i++)
      {
         int idx1 = pa.getMother1(i) - 1;
         int idx2 = pa.getMother2(i) - 1;
         //int idx1 = pa.getMother1(i); 
         //int idx2 = pa.getMother2(i); 
         int l = fillIndexVec(vec, idx1, idx2);
         //System.out.println("parent: "+i+" "+idx1+" "+idx2+" "+l);
         for (int j = 0; j < l; j++)
         {
            checkAndAddDaughter(particles, ancestors, vec[j], i);
         }
      }
      // Deal with daughters
      for (int i = 0; i < n; i++)
      {
        int idx1 = pa.getDaughter1(i) % 10000 - 1;
        int idx2 = pa.getDaughter2(i) % 10000 - 1;
        //int idx1 = pa.getDaughter1(i) % 10000;
        //int idx2 = pa.getDaughter2(i) % 10000;
        int l = fillIndexVec(vec, idx1, idx2);
        //System.out.println("child: "+i+" "+idx1+" "+idx2+" "+l);
         for (int j = 0; j < l; j++)
         {
            checkAndAddDaughter(particles, ancestors, i, vec[j]);
         }
      }
      
      // Add particles to the collection.
      for (int i=0; i<n; i++)
      {
         mcpcoll.add(particles[i]);
      }
      
      return mcpcoll;
   }








    public static void usage()
    {
        System.out.println("promc2stdhep: \n  Fonvert ProMC to to stdhep format.\n");
        System.out.println("Usage: \n\n >> java promc2stdhep file.promc file.stdhep \n");
        System.exit(0);
    }
}
